#include <stdio.h>
#include "usb.h"
#include "reset.h"
#include "dma_intr.h"
#include "interrupt.h"
#include "xusbps_comms.h"
#include "platform.h"
#include "xil_printf.h"

#define USB_BUFFER_SIZE     64 * 1024
#define HEVC_BS_CACHE_NUMS  30

// HEVC 码流缓冲区
u32 HevcBsCachePtr[HEVC_BS_CACHE_NUMS];

// HEVC 码流缓冲区索引
// 接收缓存索引（正在接收中）
u32 HevcBsCachePtrReceiveIndex  = 0;
// 发送缓存索引（等待发送中）
u32 HevcBsCachePtrTransmitIndex = 0;

// DMA 接收完成 & 出错标志位
extern int RxDone;
extern int Error;

// DMA & 中断句柄
extern XAxiDma AxiDma;
extern XScuGic Intc;
XUsbPs UsbInstance;
XScuGic IntcInstance;

/**
 * @brief  系统初始化
 * @return *
 */
void init_sys()
{
	print("Hello");
    // 初始化系统中断
    init_intr_sys();

    // 初始化 USB
    init_usb(IntcInstance, UsbInstance, USB_BUFFER_SIZE);

    // 初始化码流缓冲区
    for(int i = 0; i < HEVC_BS_CACHE_NUMS; i++)
    {
        HevcBsCachePtr[i] = RX_BUFFER_BASE + 0x00500000 * i; 
    }

    // 初始化缓冲区索引
    HevcBsCachePtrReceiveIndex  = 0;
    HevcBsCachePtrTransmitIndex = 0;

    // 复位 PL
    reset();
}

int main()
{
    // 初始化
    init_sys();
    
    // 启动 DMA 传输
    XAxiDma_SimpleTransfer(&AxiDma, (u32)HevcBsCachePtr[HevcBsCachePtrReceiveIndex], (u32)(MAX_PKT_LEN), XAXIDMA_DEVICE_TO_DMA);
    while(1)
    {
        if(RxDone)
        {
            RxDone = 0;

            if(HevcBsCachePtrReceiveIndex - HevcBsCachePtrTransmitIndex > HEVC_BS_CACHE_NUMS)
            {
                // 接收缓冲区与发送缓冲区索引差超过缓冲区长度，代表 DDR 写入速率远远高于读出速率
                // 部分数据未来得及发送就又有新数据来临，此处传输码流可能出错以导致无法解码
                printf("[ERROE] Data read/write rates are seriously inconsistent\n"); break;
            }
            
            // 确保 Cache 中的数据均在 DDR 中
            Xil_DCacheInvalidateRange((u32)HevcBsCachePtr[HevcBsCachePtrReceiveIndex % HEVC_BS_CACHE_NUMS], MAX_PKT_LEN);
            // 接收缓冲区索引自增
            // 注意此处为了减少收发缓冲区设计的难度，索引均采用非取余的方式自增，因此利用索引获取内存数据时需要取余 HEVC_BS_CACHE_NUMS
            HevcBsCachePtrReceiveIndex += 1;
            // 启动下一次 DMA 传输
            XAxiDma_SimpleTransfer(&AxiDma, (u32)HevcBsCachePtr[HevcBsCachePtrReceiveIndex % HEVC_BS_CACHE_NUMS], (u32)(MAX_PKT_LEN), XAXIDMA_DEVICE_TO_DMA);
        }
        else if(HevcBsCachePtrTransmitIndex < HevcBsCachePtrReceiveIndex)
        {
            u32 singleTransmitSize = 0;
            u32 totalTransmitSize  = 0;
            while(totalTransmitSize < MAX_PKT_LEN)
            {
                singleTransmitSize = (MAX_PKT_LEN - totalTransmitSize) > USB_BUFFER_SIZE ? USB_BUFFER_SIZE : (MAX_PKT_LEN - totalTransmitSize);
                // TODO 帧缓存地址为 u32 类型，USB 传输为 u8 类型，此处强制类型转换可能导致数据丢失
                xusb_COMMS_send_data(&UsbInstance, 
                                    (u8*)(HevcBsCachePtr[HevcBsCachePtrTransmitIndex % HEVC_BS_CACHE_NUMS] + totalTransmitSize), 
                                    singleTransmitSize);
                totalTransmitSize += singleTransmitSize;          
            }            
            HevcBsCachePtrTransmitIndex += 1;
        }
    }
    
    return 0;
}
